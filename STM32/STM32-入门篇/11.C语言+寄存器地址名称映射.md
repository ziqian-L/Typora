参考资料：

STM32F4开发指南-库函数版本_V1.1.pdf\4.1 MDK 下 C 语言基础复习 ct

STM32F4开发指南-库函数版本_V1.1.pdf\4.6 MDK 中寄存器地址名称映射分析 

8，STM32参考资料\STM32F4xx中文参考手册.pdf\第七章 通用 I/O  

### 一、C语言复习

（1）位操作

| 运算符 |   含义   | 运算符 | 含义 |
| :----: | :------: | :----: | :--: |
|   &    |  按位与  |   ~    | 取反 |
|   \|   |  按位或  |   <<   | 左移 |
|   ^    | 按位异或 |   >>   | 右移 |

[(11条消息) 七种常见的逻辑门真值表_稻草人2468的博客-CSDN博客_与或非门真值表](https://blog.csdn.net/qq_45000474/article/details/105915566)

[(11条消息) 位运算符——左移、右移_byteyoung的博客-CSDN博客_位左移右移](https://blog.csdn.net/qq_40126686/article/details/107491221) 



（2）define宏定义关键词

格式：#define	标识符	字符串

例：#define	Cola	3



（3）ifdef条件编译

[(11条消息) 条件编译#ifdef的妙用详解_透彻_司马如风的博客-CSDN博客_ifdef](https://blog.csdn.net/qq_36662437/article/details/81476572) 



（4）extern变量申明

[C语言extern作用（全局变量） - 小人物702 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaorenwu702/p/5739845.html#:~:text=%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A%20%E4%BD%BF%E7%94%A8%20extern%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%9D%A5%20%E5%A3%B0%E6%98%8E,%E5%8F%98%E9%87%8F%E4%B8%BA%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%82%20%E5%85%B7%E4%BD%93%E8%AF%B4%E5%B0%B1%E6%98%AF%E5%9C%A8%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AAc%E6%96%87%E4%BB%B6%E4%B8%AD%20%E5%AE%9A%E4%B9%89%20%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8Fkey%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A6%81%E4%BD%BF%E7%94%A8key%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84c%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%20%E5%A3%B0%E6%98%8E%20%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%AF%B4%E6%98%8E%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E4%B8%BA%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E6%98%AF%E5%9C%A8%E5%85%B6%E4%BB%96%E7%9A%84c%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%82) 



（5）typedef类型别名

使用关键字**typedef**可以为类型起一个新的别名，语法格式为：

typedef  oldName  newName;

typedef 还可以给数组、指针、结构体等类型定义别名。 



（6）结构体

[(11条消息) C语言结构体定义的几种方法_wowocpp的博客-CSDN博客_c语言结构体定义](https://blog.csdn.net/wowocpp/article/details/79487557) 

（7）static关键字

编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的。

普通局部变量存储于进程栈空间，使用完毕会立即释放。

静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。

第一次被引用时初始化，并且只初始化一次 

[C++中static变量的初始化_lucky-billy的博客-CSDN博客_c++ static成员变量初始化](https://blog.csdn.net/qq_34139994/article/details/105157313) 

### 二、寄存器地址名称映射

- 51中映射的方法：

  sfr P0=0x80;//P0映射到0x80

  P0=0x00;//往寄存器地址0x80赋值0x00

- STM32中的操作

   GPIOA->ODR=0x00000000;

  GPIOA->ODR如何与GPIOA的ODR寄存器地址映射起来

  1#define PERIPH_BASE ((uint32_t)0x40000000)

  ​				$\downarrow$

  2#define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000)

  ​				$\downarrow$

  3#define GPIOA_BASE (AHB1PERIPH_BASE + 0x0000)

  ​				$\downarrow$

  4#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)

  所以我们便可以算出 GPIOA 的基地址位：

  GPIOA_BASE= 0x40000000+0x00020000+0x0000=0x40020000

  

  GPIOA 的寄存器的地址=GPIOA 基地址+寄存器相对 GPIOA 基地址的偏移值

  对于结构体类型 GPIO_TypeDef，他的所有成员变量都是 32 位，成 

  员变量地址具有连续性。

  一个寄存器占四位所以有

  |     寄存器     | 偏移地址 | 实际地址=基地址+偏移地址 |
  | :------------: | :------: | :----------------------: |
  |  GPIOA_MODER   |   0x00   |     0x40020000+0x00      |
  |  GPIOA_OTYPER  |   0x04   |     0x40020000+0x04      |
  | GPIOA_OSPEEDER |   0x08   |     0x40020000+0x08      |
  |  GPIOA_PUPDR   |   0x0C   |     0x40020000+0x0C      |
  |   GPIOA_IDR    |   0x10   |     0x40020000+0x10      |
  |   GPIOA_ODR    |   0x14   |     0x40020000+0x14      |
  |   GPIOA_BSRR   |   0x18   |     0x40020000+0x18      |
  |   GPIOA_LCKR   |   0x1C   |     0x40020000+0x1C      |
  |   GPIOA_AFRL   |   0x20   |     0x40020000+0x20      |
  |   GPIOA_AFRH   |   0x24   |     0x40020000+0x24      |

  综上可知，GPIOA->ODR=0x00000000;就是把0x40020000+0x14这个地址的值变成0x00000000
